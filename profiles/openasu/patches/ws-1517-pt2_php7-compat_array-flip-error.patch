diff --git a/includes/entity.controller.inc b/includes/entity.controller.inc
index 5e86b52..8b0cdc9 100644
--- a/includes/entity.controller.inc
+++ b/includes/entity.controller.inc
@@ -216,7 +216,7 @@ class EntityAPIController extends DrupalDefaultEntityController implements Entit
     // were passed. The $ids array is reduced as items are loaded from cache,
     // and we need to know if it's empty for this reason to avoid querying the
     // database when all requested entities are loaded from cache.
-    $passed_ids = !empty($ids) ? array_flip($ids) : FALSE;
+    $passed_ids = is_array($ids) && !empty($ids) ? array_flip(array_filter($ids)) : FALSE;
 
     // Try to load entities from the static cache.
     if ($this->cache && !$revision_id) {
@@ -739,7 +739,7 @@ class EntityAPIControllerExportable extends EntityAPIController {
     else {
       $revision_id = FALSE;
     }
-    $passed_ids = !empty($ids) ? array_flip($ids) : FALSE;
+    $passed_ids = is_array($ids) && !empty($ids) ? array_flip(array_filter($ids)) : FALSE;
 
     // Care about the static cache.
     if ($this->cache && !$revision_id) {
@@ -770,7 +770,7 @@ class EntityAPIControllerExportable extends EntityAPIController {
    */
   protected function cacheGet($ids, $conditions = array()) {
     if (!empty($this->entityCache) && $ids !== array()) {
-      $entities = $ids ? array_intersect_key($this->entityCache, array_flip($ids)) : $this->entityCache;
+      $entities = $ids && is_array($ids) ? array_intersect_key($this->entityCache, array_flip(array_filter($ids))) : $this->entityCache;
       return $this->applyConditions($entities, $conditions);
     }
     return array();
@@ -780,11 +780,11 @@ class EntityAPIControllerExportable extends EntityAPIController {
    * Like cacheGet() but keyed by name.
    */
   protected function cacheGetByName($names, $conditions = array()) {
-    if (!empty($this->entityCacheByName) && $names !== array() && $names) {
+    if (!empty($this->entityCacheByName) && is_array($names) && $names !== array() && $names) {
       // First get the entities by ids, then apply the conditions.
       // Generally, we make use of $this->entityCache, but if we are loading by
       // name, we have to use $this->entityCacheByName.
-      $entities = array_intersect_key($this->entityCacheByName, array_flip($names));
+      $entities = array_intersect_key($this->entityCacheByName, array_flip(array_filter($names)));
       return $this->applyConditions($entities, $conditions);
     }
     return array();
@@ -866,7 +866,7 @@ class EntityAPIControllerExportable extends EntityAPIController {
   public function resetCache(array $ids = NULL) {
     $this->cacheComplete = FALSE;
     if (isset($ids)) {
-      foreach (array_intersect_key($this->entityCache, array_flip($ids)) as $id => $entity) {
+      foreach (array_intersect_key($this->entityCache, array_flip(array_filter($ids))) as $id => $entity) {
         unset($this->entityCacheByName[$this->entityCache[$id]->{$this->nameKey}]);
         unset($this->entityCache[$id]);
       }
diff --git a/includes/entity.wrapper.inc b/includes/entity.wrapper.inc
index 70c14c1..a592388 100644
--- a/includes/entity.wrapper.inc
+++ b/includes/entity.wrapper.inc
@@ -1162,7 +1162,7 @@ class EntityListWrapper extends EntityMetadataWrapper implements IteratorAggrega
   public function label() {
     if ($options = $this->optionsList('view')) {
       $options = entity_property_options_flatten($options);
-      $labels = array_intersect_key($options, array_flip((array) parent::value()));
+      $labels = array_intersect_key($options, array_flip(array_filter((array) parent::value())));
     }
     else {
       // Get each label on its own, e.g. to support getting labels of a list
diff --git a/modules/callbacks.inc b/modules/callbacks.inc
index ee156ab..934bf71 100644
--- a/modules/callbacks.inc
+++ b/modules/callbacks.inc
@@ -386,7 +386,7 @@ function entity_metadata_user_get_properties($account, array $options, $name, $e
 function entity_metadata_user_set_properties($account, $name, $value) {
   switch ($name) {
     case 'roles':
-      $account->roles = array_intersect_key(user_roles(), array_flip($value));
+      $account->roles = array_intersect_key(user_roles(), array_flip(array_filter((array) $value)));
       break;
   }
 }

